---
title: 【 数据库 】事务与分布式事务
date: 2016-02-10 16:06:49
tags: 数据库
---

# 事务

## 事务简介
本质：锁和并发，容易理解但性能较低。

单个事务单元：事务保证一致性，中间状态不会出现。ACID保证事务完整性。例如：从数据库中读取一行记录、向数据库中谢茹一行记录，同时更新这行记录的所有索引、删除整张表、加入索引、删除索引.... 所有对数据库的一个操作都是一个事务。

一组事务单元：事务单元之间的 Happen-before 关系（读写、写读、读读、写写）

### 事务 - 排队法
序列化读写，不需要冲突控制，慢速设备时，系统性能很低。

### 事务 - 排他锁
针对 `同一个单元` 的访问进行控制，例如：Bob 给 Smith 100元， Jack 给 Alice 100元，不发生冲突则可以并行。

### 事务 - 读写锁
分读锁和写锁，加大读时的并行度。可重复读能保证读读并行。
去掉读锁，只有写锁：读写 以及 写读可以并行，隔离性（隔离级别） 破坏了 一致性。

### 事务 - MVCC
本质是 copy on write，针对 `写读` 的优化，能够做到写不阻塞读，写时可以做到并发读。系统实现的复杂度会增加。

<br/>

## 事务处理常见问题
### 谁先谁后
方法：使用逻辑时间戳，可以保证事务本身的先后顺序。

### 故障恢复
业务属性不匹配 或 系统崩溃：事务回滚，需要恢复故障，在此期间不执行其他事务。

### 死锁与死锁检测
死锁产生的原因：两个线程、不同方向、相同资源。
解决方法：**碰撞检测**（将事务持有锁的情况存到内存中，检测到死锁，则终止一边事务）、等锁超时

<br/>

# 单机事务
## 事务的 ACID

### 原子性
一个事务要么同时成功，要么同时失败。原子性的保证方法：在 undo 日志中记录回滚段 undo 信息，正向操作的逆向操作。

### 一致性
事务与事务的 happen-before 关系，一致性保证能看到系统内的所有更改。

### 隔离性
以性能为理由，对一致性的破坏。
有四种隔离级别：读已提交、读未提交、可重复读以及序列化读。
排它锁：序列化读写，将所有请求排队，在单位时间内只有一个事务在执行，性能差系统不可用；
读写锁：1. 隔离级别：可重复读，读锁不能被写锁升级，读读可并行；2. 隔离级别：读已提交，读锁可升级为写锁，读读可并行，读写可并行；3. 隔离级别：读未提交，只加写锁，读不加锁，读读可并行，读写可并行，写读可并行；可能会读到中间状态。
快照隔离性（MVCC）：针对读多写少场景优化；并行度达到或超过读未提交，而隔离级别很高。快照读的情况下能保证在读到一致性的同时实现读未提交。

### 持久性
事务完成之后，该事务对数据库所做的更改便持久的保存在数据库之中。

如何才能确保数据不丢？传统方式RAID的持久性。1）磁盘的物理损坏 2）每次 commit 都要 fsync 到磁盘上的话，系统性能低。

# 事务的调优原则
在不影响业务应用的前提下
1. 减少锁的覆盖范围：表锁缩小范围至行锁，原位锁缩小范围至 MVCC 多版本；
2. 增加锁上可并行的线程数，读锁写锁分离、允许并行读取数据。
3. 选择正确锁类型：悲观锁（数据加锁后使线程到 blocking 状态，通知信息 ok 的状态切换回等待状态），适合并发争抢比较严重的场景；乐观锁适合并发争抢不是很严重的场景。
